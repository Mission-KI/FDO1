/* eslint-disable */
/**
 * FDO Manager Service API
 * The FDO Manager Service API for creating FAIR Digital Objects.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: t.fitschen@indiscale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface DigitalObject
 */
export interface DigitalObject {
    /**
     * 
     * @type {string}
     * @memberof DigitalObject
     */
    'pid': string;
    /**
     * 
     * @type {boolean}
     * @memberof DigitalObject
     */
    'isFdo': boolean;
    /**
     * 
     * @type {string}
     * @memberof DigitalObject
     */
    'dataPid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalObject
     */
    'metadataPid'?: string;
}
/**
 * 
 * @export
 * @interface GetInfo200Response
 */
export interface GetInfo200Response {
    /**
     * 
     * @type {Info}
     * @memberof GetInfo200Response
     */
    'data': Info;
    /**
     * 
     * @type {Links}
     * @memberof GetInfo200Response
     */
    'links'?: Links;
}
/**
 * 
 * @export
 * @interface GetProfile200Response
 */
export interface GetProfile200Response {
    /**
     * 
     * @type {Profile}
     * @memberof GetProfile200Response
     */
    'data': Profile;
    /**
     * 
     * @type {Links}
     * @memberof GetProfile200Response
     */
    'links'?: Links;
}
/**
 * 
 * @export
 * @interface GetRepository200Response
 */
export interface GetRepository200Response {
    /**
     * 
     * @type {Repository}
     * @memberof GetRepository200Response
     */
    'data': Repository;
    /**
     * 
     * @type {Links}
     * @memberof GetRepository200Response
     */
    'links'?: Links;
}
/**
 * 
 * @export
 * @interface Hello
 */
export interface Hello {
    /**
     * 
     * @type {string}
     * @memberof Hello
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'fdoServiceVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'fdoSdkVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'serviceProvider'?: string;
    /**
     * 
     * @type {SelfLink}
     * @memberof Info
     */
    'links'?: SelfLink;
}
/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    'self'?: string;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    'collection'?: string;
}
/**
 * 
 * @export
 * @interface ListLogEvents200Response
 */
export interface ListLogEvents200Response {
    /**
     * 
     * @type {Array<OperationsLogRecord>}
     * @memberof ListLogEvents200Response
     */
    'data'?: Array<OperationsLogRecord>;
    /**
     * 
     * @type {PaginationLinks}
     * @memberof ListLogEvents200Response
     */
    'links'?: PaginationLinks;
}
/**
 * 
 * @export
 * @interface ListProfiles200Response
 */
export interface ListProfiles200Response {
    /**
     * 
     * @type {Array<Profile>}
     * @memberof ListProfiles200Response
     */
    'data'?: Array<Profile>;
    /**
     * 
     * @type {Links}
     * @memberof ListProfiles200Response
     */
    'links'?: Links;
}
/**
 * 
 * @export
 * @interface ListRepositories200Response
 */
export interface ListRepositories200Response {
    /**
     * 
     * @type {Array<Repository>}
     * @memberof ListRepositories200Response
     */
    'data'?: Array<Repository>;
    /**
     * 
     * @type {Links}
     * @memberof ListRepositories200Response
     */
    'links'?: Links;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface OperationsLogRecord
 */
export interface OperationsLogRecord {
    /**
     * 
     * @type {string}
     * @memberof OperationsLogRecord
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OperationsLogRecord
     */
    'type'?: string;
    /**
     * 
     * @type {OperationsLogRecordAttributes}
     * @memberof OperationsLogRecord
     */
    'attributes'?: OperationsLogRecordAttributes;
    /**
     * 
     * @type {SelfLink}
     * @memberof OperationsLogRecord
     */
    'links'?: SelfLink;
}
/**
 * 
 * @export
 * @interface OperationsLogRecordAttributes
 */
export interface OperationsLogRecordAttributes {
    /**
     * 
     * @type {string}
     * @memberof OperationsLogRecordAttributes
     */
    'operation'?: OperationsLogRecordAttributesOperationEnum;
    /**
     * 
     * @type {string}
     * @memberof OperationsLogRecordAttributes
     */
    'timestamp'?: string;
    /**
     * 
     * @type {TargetRepositories}
     * @memberof OperationsLogRecordAttributes
     */
    'repositories'?: TargetRepositories;
    /**
     * 
     * @type {DigitalObject}
     * @memberof OperationsLogRecordAttributes
     */
    'fdo'?: DigitalObject;
}

export const OperationsLogRecordAttributesOperationEnum = {
    OpCreate: 'Op.Create'
} as const;

export type OperationsLogRecordAttributesOperationEnum = typeof OperationsLogRecordAttributesOperationEnum[keyof typeof OperationsLogRecordAttributesOperationEnum];

/**
 * 
 * @export
 * @interface PaginationLinks
 */
export interface PaginationLinks {
    /**
     * 
     * @type {string}
     * @memberof PaginationLinks
     */
    'self'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationLinks
     */
    'first'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationLinks
     */
    'prev'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationLinks
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationLinks
     */
    'last'?: string;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'id'?: string;
    /**
     * 
     * @type {Links}
     * @memberof Profile
     */
    'links'?: Links;
}
/**
 * 
 * @export
 * @interface Repository
 */
export interface Repository {
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Repository
     */
    'type'?: RepositoryTypeEnum;
    /**
     * 
     * @type {RepositoryAttributes}
     * @memberof Repository
     */
    'attributes'?: RepositoryAttributes;
    /**
     * 
     * @type {Links}
     * @memberof Repository
     */
    'links'?: Links;
}

export const RepositoryTypeEnum = {
    Repository: 'Repository'
} as const;

export type RepositoryTypeEnum = typeof RepositoryTypeEnum[keyof typeof RepositoryTypeEnum];

/**
 * 
 * @export
 * @interface RepositoryAttributes
 */
export interface RepositoryAttributes {
    /**
     * 
     * @type {string}
     * @memberof RepositoryAttributes
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryAttributes
     */
    'maintainer'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RepositoryAttributes
     */
    'attributes'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ResolvePID200Response
 */
export interface ResolvePID200Response {
    /**
     * 
     * @type {DigitalObject}
     * @memberof ResolvePID200Response
     */
    'data': DigitalObject;
    /**
     * 
     * @type {Links}
     * @memberof ResolvePID200Response
     */
    'links'?: Links;
}
/**
 * 
 * @export
 * @interface SelfLink
 */
export interface SelfLink {
    /**
     * 
     * @type {string}
     * @memberof SelfLink
     */
    'self'?: string;
}
/**
 * 
 * @export
 * @interface TargetRepositories
 */
export interface TargetRepositories {
    /**
     * 
     * @type {string}
     * @memberof TargetRepositories
     */
    'fdo'?: string;
    /**
     * 
     * @type {string}
     * @memberof TargetRepositories
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof TargetRepositories
     */
    'data'?: string;
}

/**
 * FDOsApi - axios parameter creator
 * @export
 */
export const FDOsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an FDO.
         * @param {TargetRepositories} repositories 
         * @param {File} data 
         * @param {File} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFDO: async (repositories: TargetRepositories, data: File, metadata: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositories' is not null or undefined
            assertParamExists('createFDO', 'repositories', repositories)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createFDO', 'data', data)
            // verify required parameter 'metadata' is not null or undefined
            assertParamExists('createFDO', 'metadata', metadata)
            const localVarPath = `/fdo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (repositories !== undefined) { 
                localVarFormParams.append('repositories', new Blob([JSON.stringify(repositories)], { type: "application/json", }));
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', metadata as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve a pid.
         * @param {string} prefix Persistent Identifier Prefix
         * @param {string} suffix Persistent Identifier Suffix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolvePID: async (prefix: string, suffix: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('resolvePID', 'prefix', prefix)
            // verify required parameter 'suffix' is not null or undefined
            assertParamExists('resolvePID', 'suffix', suffix)
            const localVarPath = `/fdo/{prefix}/{suffix}`
                .replace(`{${"prefix"}}`, encodeURIComponent(String(prefix)))
                .replace(`{${"suffix"}}`, encodeURIComponent(String(suffix)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FDOsApi - functional programming interface
 * @export
 */
export const FDOsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FDOsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an FDO.
         * @param {TargetRepositories} repositories 
         * @param {File} data 
         * @param {File} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFDO(repositories: TargetRepositories, data: File, metadata: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFDO(repositories, data, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FDOsApi.createFDO']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resolve a pid.
         * @param {string} prefix Persistent Identifier Prefix
         * @param {string} suffix Persistent Identifier Suffix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolvePID(prefix: string, suffix: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolvePID200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolvePID(prefix, suffix, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FDOsApi.resolvePID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FDOsApi - factory interface
 * @export
 */
export const FDOsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FDOsApiFp(configuration)
    return {
        /**
         * Create an FDO.
         * @param {TargetRepositories} repositories 
         * @param {File} data 
         * @param {File} metadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFDO(repositories: TargetRepositories, data: File, metadata: File, options?: any): AxiosPromise<void> {
            return localVarFp.createFDO(repositories, data, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolve a pid.
         * @param {string} prefix Persistent Identifier Prefix
         * @param {string} suffix Persistent Identifier Suffix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolvePID(prefix: string, suffix: string, options?: any): AxiosPromise<ResolvePID200Response> {
            return localVarFp.resolvePID(prefix, suffix, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FDOsApi - object-oriented interface
 * @export
 * @class FDOsApi
 * @extends {BaseAPI}
 */
export class FDOsApi extends BaseAPI {
    /**
     * Create an FDO.
     * @param {TargetRepositories} repositories 
     * @param {File} data 
     * @param {File} metadata 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FDOsApi
     */
    public createFDO(repositories: TargetRepositories, data: File, metadata: File, options?: RawAxiosRequestConfig) {
        return FDOsApiFp(this.configuration).createFDO(repositories, data, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolve a pid.
     * @param {string} prefix Persistent Identifier Prefix
     * @param {string} suffix Persistent Identifier Suffix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FDOsApi
     */
    public resolvePID(prefix: string, suffix: string, options?: RawAxiosRequestConfig) {
        return FDOsApiFp(this.configuration).resolvePID(prefix, suffix, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve general information on the service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Say hello to the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hello`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve general information on the service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.getInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Say hello to the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hello>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.hello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * Retrieve general information on the service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<GetInfo200Response> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Say hello to the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hello(options?: any): AxiosPromise<Hello> {
            return localVarFp.hello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * Retrieve general information on the service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getInfo(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Say hello to the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public hello(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).hello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LoggingApi - axios parameter creator
 * @export
 */
export const LoggingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List latest log events
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogEvents: async (pageNumber?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logging`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoggingApi - functional programming interface
 * @export
 */
export const LoggingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoggingApiAxiosParamCreator(configuration)
    return {
        /**
         * List latest log events
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLogEvents(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLogEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLogEvents(pageNumber, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoggingApi.listLogEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LoggingApi - factory interface
 * @export
 */
export const LoggingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoggingApiFp(configuration)
    return {
        /**
         * List latest log events
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogEvents(pageNumber?: number, pageSize?: number, options?: any): AxiosPromise<ListLogEvents200Response> {
            return localVarFp.listLogEvents(pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoggingApi - object-oriented interface
 * @export
 * @class LoggingApi
 * @extends {BaseAPI}
 */
export class LoggingApi extends BaseAPI {
    /**
     * List latest log events
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoggingApi
     */
    public listLogEvents(pageNumber?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return LoggingApiFp(this.configuration).listLogEvents(pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information on a single profile.
         * @param {string} profileId Profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (profileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('getProfile', 'profileId', profileId)
            const localVarPath = `/profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List known profiles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information on a single profile.
         * @param {string} profileId Profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(profileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProfile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(profileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.getProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List known profiles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProfiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProfiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProfiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.listProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * Get information on a single profile.
         * @param {string} profileId Profile ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(profileId: string, options?: any): AxiosPromise<GetProfile200Response> {
            return localVarFp.getProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * List known profiles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles(options?: any): AxiosPromise<ListProfiles200Response> {
            return localVarFp.listProfiles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * Get information on a single profile.
     * @param {string} profileId Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public getProfile(profileId: string, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).getProfile(profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List known profiles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public listProfiles(options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).listProfiles(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesApi - axios parameter creator
 * @export
 */
export const RepositoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information on a single repository.
         * @param {string} repositoryId Repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepository: async (repositoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getRepository', 'repositoryId', repositoryId)
            const localVarPath = `/repositories/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List trusted repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepositories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesApi - functional programming interface
 * @export
 */
export const RepositoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information on a single repository.
         * @param {string} repositoryId Repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepository(repositoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRepository200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepository(repositoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.getRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List trusted repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepositories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRepositories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepositories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoriesApi.listRepositories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RepositoriesApi - factory interface
 * @export
 */
export const RepositoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesApiFp(configuration)
    return {
        /**
         * Get information on a single repository.
         * @param {string} repositoryId Repository ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepository(repositoryId: string, options?: any): AxiosPromise<GetRepository200Response> {
            return localVarFp.getRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List trusted repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepositories(options?: any): AxiosPromise<ListRepositories200Response> {
            return localVarFp.listRepositories(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesApi - object-oriented interface
 * @export
 * @class RepositoriesApi
 * @extends {BaseAPI}
 */
export class RepositoriesApi extends BaseAPI {
    /**
     * Get information on a single repository.
     * @param {string} repositoryId Repository ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public getRepository(repositoryId: string, options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).getRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List trusted repositories.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesApi
     */
    public listRepositories(options?: RawAxiosRequestConfig) {
        return RepositoriesApiFp(this.configuration).listRepositories(options).then((request) => request(this.axios, this.basePath));
    }
}



